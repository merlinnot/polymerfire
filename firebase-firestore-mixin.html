<link rel="import" href="firebase-firestore-script.html">
<script>
  (() => {
    const CONSTRUCTOR_TOKEN = Symbol('polymerfire-firestore-mixin-constructor');
    const CONNECTED_CALLBACK_TOKEN =
      Symbol('polymerfire-firestore-mixin-connected-callback');
    const PROPERTY_BINDING_REGEXP = /{([^{]+)}/g;

    const DEFAULT_PROPERTY_CONFIG = {
      live: false,
      observes: [],
    };

    const DOCUMENT_PROPERTY_NAME = 'doc';
    const COLLECTION_PROPERTY_NAME = 'collection';

    const READY_SUFFIX = 'Ready';
    const REFERENCE_SUFFIX = 'Ref';
    const FIRESTORE_INSTANCE_PATH = 'db';

    const isOdd = x => x & 1 === 1;
    const isDefined = x => x !== undefined;    

    let firestoreInstance = undefined;
    const assignFirestoreInstanceIfUndefined = instance => {
      if (!isDefined(instance[FIRESTORE_INSTANCE_PATH])) {
        instance[FIRESTORE_INSTANCE_PATH] = isDefined(firestoreInstance)
          ? firestoreInstance
          : firestoreInstance = firebase.firestore();
      }
    }

    const parsePath = (path) => {
      const parts = path.split(PROPERTY_BINDING_REGEXP);
      let literals = [], props = [];
      parts.forEach((part, index) => {
        (isOdd(index) ? props : literals).push(part);
      })
      return { literals, props };
    }

    const stitch = (literals, values) => {
      let whole = '';
      for (var i = 0; i < literals.length; i++) {
        whole += literals[i];
        whole += values[i] || '';
      }
      return whole;
    }

    const collect = (what, which) => {
      let res = {};
      while (what) {
        res = Object.assign({}, what[which], res); // Respect prototype priority
        what = Object.getPrototypeOf(what);
      }
      return res;
    };

    const assertPropertyTypeCorrectness = prop => {
      const errorMessage = (listenerType, propertyType) =>
        `FirestoreMixin's ${listenerType} can only be used with properties ` +
        `of type ${propertyType}.`;
      const assert = (listenerType, propertyType) => {
        if (isDefined(prop[listenerType]) && prop.type !== propertyType) {
          throw new Error(errorMessage(listenerType, propertyType.name));
        }
      }

      assert('doc', Object);
      assert('collection', Array);
    }

    const getConfig = options => {
      const path = isDefined(options.doc)
        ? options.doc
        : options.collection;
      const parsedPath = parsePath(path);
      const type = isDefined(options[DOCUMENT_PROPERTY_NAME])
        ? DOCUMENT_PROPERTY_NAME
        : COLLECTION_PROPERTY_NAME;

      return Object.assign(
        {},
        DEFAULT_PROPERTY_CONFIG,
        options,
        parsedPath,
        {type},
      );
    }

    const splitArgsIfDefined = (config, args) => {
      const props = args.slice(0, config.props.length).filter(isDefined);
      const observes = args.slice(config.props.length).filter(isDefined);

      const propsReady = props.length === config.props.length;
      const observesReady = observes.length === config.observes.length;

      return propsReady === true && observesReady === true
        ? { props, observes }
        : undefined;
    }

    const getDoc = snap => {
      if (snap.exists) {
        return Object.assign({ __id__: snap.id }, snap.data());
      } else {
        return null;
      }
    }

    const assignDocument = (instance, name, snap) => {
      instance[name] = getDoc(snap);
    }

    const assignCollection = (instance, name, snap) => {
      const propertyValueIsArray = Array.isArray(instance[name])
      const allDocumentsChanged = snap.docs.length === snap.docChanges.length;
      if (propertyValueIsArray && allDocumentsChanged === false) {
        snap.docChanges.forEach((change) => {
          switch (change.type) {
            case 'added':
              instance.splice(name, change.newIndex, 0, getDoc(change.doc));
              break;
            case 'removed':
              instance.splice(name, change.oldIndex, 1);
              break;
            case 'modified':
              if (change.oldIndex === change.newIndex) {
                instance.splice(name, change.oldIndex, 1, getDoc(change.doc));
              } else {
                instance.splice(name, change.oldIndex, 1);
                instance.splice(name, change.newIndex, 0, getDoc(change.doc));
              }
              break;
            default:
              throw new Error(`Unhandled document change: ${change.type}.`);
          }
        });
      } else {
        instance[name] = snap.docs.map(assignDocument);
      }
    }

    const makeAssigner = (instance, name, { type, live, noCache }) => {
      const makeAssignerHandler = (assigner) => (snap) => {
        const shouldAssign =
          noCache !== true || snap.metadata.fromCache === false;
        if (shouldAssign) {
          assigner(instance, name, snap);
          instance[name + READY_SUFFIX] = true;
          if (live !== true) {
            instance.__firestoreListeners[name]();
          }
        }
      }

      if (type === DOCUMENT_PROPERTY_NAME) {
        return makeAssignerHandler(assignDocument);
      } else if (type === COLLECTION_PROPERTY_NAME) {
        return makeAssignerHandler(assignCollection);
      } else {
        throw new Error('Unknown listener type.');
      }
    }

    /**
     * This mixin provides bindings to documents and collections in a
     * Cloud Firestore database through special property declarations.
     *
     * ### Basic Usage
     *
     * ```js
     * class MyElement extends Polymer.FirestoreMixin(Polymer.Element) {
     *   // ...
     *   static get properties() {
     *     return {
     *       uid: String,
     *       user: {
     *         type: Object,
     *         doc: 'users/{uid}'
     *       },
     *       messages: {
     *         type: Array,
     *         collection: 'users/{uid}/messages'
     *       }
     *     }
     *   }
     * }
     * ```
     *
     * As you can see, specific properties have been decorated with `doc` and
     * `collection` options. These options provide full paths to documents or
     * collections in your Firestore database. When templatized with curly
     * braces (e.g. `{uid}` above), the data will be dynamically rebound as
     * the templatized properties change.
     *
     * PolymerFirestore bindings are **intentionally read-only**. Automatic
     * three-way binding (i.e. syncing changes from the element back up to
     * the database) are great for toy apps but largely an antipattern.
     *
     * In addition to loading data into the specified property, PolymerFirestore
     * also makes additional convenience properties:
     *
     * * `<propname>Ref`: a Firestore reference to the doc/collection
     * * `<propname>Ready`: will be true when all path segments are present and data has been fetched at least once
     *
     * ### Querying
     *
     * PolymerFire supports querying by supplying a builder function to the
     * `query` option. The function will be bound to the element and called with
     * the ref instance and `this` as element instance. For example:
     *
     * ```js
     * {
     *   uid: String,
     *   label: String,
     *   category: String,
     *   notes: {
     *     type: Array,
     *     collection: 'users/{uid}/notes',
     *     query: (q) => {
     *       q = q.orderBy('date', 'desc').limit(100)
     *       if (this.color) { q = q.where('color','==', el.color) }
     *       if (this.category) { q = q.where('category', '==', el.category) }
     *       return q;
     *     },
     *     observes: ['color', 'category']
     *   }
     * }
     * ```
     *
     * In the  above example, a rich query is further filtered down by other
     * properties on the element. Remember to declare each query-affecting
     * property in your `observes` option.
     *
     * ### Options
     *
     * * **doc:** *string*, the full (optionally templatized) path to a document.
     *   Property type must be defined as `Object`
     * * **collection:** *string*, the full (optionally templatized) path to
     *   a collection. Property type must be defined as `Array`.
     * * **live:** *boolean*, whether or not to continue updating the property
     *   as data changes in the database. If persistence is enabled, value of
     *   a property might be assigned twice (first from cache, then a live copy).
     *   See `noCache` if you wan't to change this behavior.
     * * **query:** *(ref: CollectionReference): Query*
     *   a query builder function that takes the computed collection reference and
     *   the element instance. It must return an instance of Query.
     * * **observes:** a list of properties which, if changed, should trigger
     *   a rebuild of a listener.
     * * **noCache:** cached Firestore data won't be assigned to a property
     *   value even if persistence is enabled.
     *
     * @polymer
     * @mixinFunction Polymer.FirestoreMixin
     */
    Polymer.FirestoreMixin = superClass =>
      class extends superClass {
        constructor() {
          super();
          
          if (this[CONSTRUCTOR_TOKEN] !== true) {
            this[CONSTRUCTOR_TOKEN] = true;

            this.__firestoreProps = {};
            this.__firestoreListeners = {};
          }
        }

        connectedCallback() {
          if (this[CONNECTED_CALLBACK_TOKEN] !== true) {
            this[CONNECTED_CALLBACK_TOKEN] = true;

            const intialize = () => {
              const props = collect(this.constructor, 'properties');
              Object.values(props).forEach(assertPropertyTypeCorrectness);

              for (let name in props) {
                const options = props[name];
                const isDocOrCollection =
                  isDefined(options.doc) || isDefined(options.collection);
                if (isDocOrCollection) {
                  this._firestoreBind(name, options);
                }
              }
            }

            if (firebase.apps.length > 0) {
              intialize();
            } else {
              window.addEventListener('firebase-app-initialized', intialize);
            }
          }

          super.connectedCallback();
        }

        _firestoreBind(name, options) {
          const config = this.__firestoreProps[name] = getConfig(options);

          const args = config.props.concat(config.observes);
          if (args.length > 0) {
            // Create a method observer that will be called every time
            // a templatized or observed property changes.
            const observer =
              `_firestoreUpdateBinding('${name}', ${args.join(',')})`
            this._createMethodObserver(observer);
          }

          // Try to update binding immediately, properties might be already
          // defined.
          this._firestoreUpdateBinding(name, ...args.map(x => this[x]));
        }

        _firestoreUpdateBinding(name, ...args) {
          const config = this.__firestoreProps[name];
          this._firestoreUnlisten(name, config.type);
          const splittedArgs = splitArgsIfDefined(config, args);

          if (isDefined(splittedArgs)) {
            const {props, observes} = splittedArgs;
            const collPath = stitch(config.literals, props);
            const assigner = makeAssigner(this, name, config);

            assignFirestoreInstanceIfUndefined(this);

            const ref = this[FIRESTORE_INSTANCE_PATH][config.type](collPath);
            const maybeQueriedRef =
              this[name + REFERENCE_SUFFIX] =
                config.query !== undefined
                  ? config.query.call(this, ref)
                  : ref;

            this.__firestoreListeners[name] =
              maybeQueriedRef.onSnapshot(assigner);
          }
        }

        _firestoreUnlisten(name, type) {
          if (this.__firestoreListeners[name]) {
            this.__firestoreListeners[name]();
            delete this.__firestoreListeners[name];
          }

          console.log(type)

          this.setProperties({
            [name]: type === COLLECTION_PROPERTY_NAME ? [] : null,
            [name + REFERENCE_SUFFIX]: null,
            [name + READY_SUFFIX]: false,
          })
        }
      }
  })(Polymer || (Polymer = {}))
</script>